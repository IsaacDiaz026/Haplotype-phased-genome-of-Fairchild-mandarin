#2022-01-15
library(dplyr)
library(gtools)
library(ggpubr)
library(ggplot2)


##Analyzing correlation of haplotype counts between AS marks, ASE gene expression, and Non AS marks , Non ASE expression

#This file is Every ASE promoter and its nearest AS mark
#ASE promoters are from the first RNA seq rep, I will intersect data from matching ASE promoters in REP2

Closest_AS_toASE_promoters <- read.delim("Closest_AS_toASE_promoters.bed", header=FALSE)

#This next file was generated using the following command
#It intersects the ASE promoters with the phase blocks generated by 10x linked reads, while carrying voer the information about the closest AS mark

ASE_prom_closestASmarks_phaseblocks <- read.delim("ASE_prom_closestASmarks_phaseblocks.txt", header=FALSE)

colnames(ASE_prom_closestASmarks_phaseblocks) <- c("ASE_gene_chr", "gene_start", "gene_end","strand","geneid","Mark","AS_mark_chr","peak_start","peak_end","peakid","gene_peak_distance","phs_block_chr","phs_block_start","phs_block_end")

table(Closest_AS_toASE_promoters$V6)
table(ASE_prom_closestASmarks_phaseblocks$Mark)

before_phs_genes <- Closest_AS_toASE_promoters[,c(1:3)]
after_phs_genes <- ASE_prom_closestASmarks_phaseblocks[,c(1:3)]
colnames(before_phs_genes) <- colnames(after_phs_genes)
head(before_phs_genes)
head(after_phs_genes)

print("Number of genes lost after merging with phase blocks")

print(dim(unique(anti_join(before_phs_genes,after_phs_genes, by =c("gene_start")))))

print("Filter only ASE genes + AS mark that are in the same phase block ")
Same_block <- ASE_prom_closestASmarks_phaseblocks %>% filter(ASE_gene_chr == phs_block_chr & gene_start >= phs_block_start & gene_end <= phs_block_end & peak_start >= phs_block_start & peak_end <= phs_block_end)

print("How many features are lost when filtering")
print("Print before filtering")
print(table(ASE_prom_closestASmarks_phaseblocks$Mark))
print("After filtering")
print(table(Same_block$Mark))


print("Load in AS features and their coordinates, AS features were subsetted in RegioneR_analysis.R")

ATAC_AS_wID <- read.delim("ATAC_AS_wID.bed", header=FALSE)

H3K27me3_AS_wID <- read.delim("H3K27me3_AS_wID.bed", header=FALSE)

H3K36me3_AS_wID <- read.delim("H3K36me3_AS_wID.bed", header=FALSE)

H3K56ac_AS_wID <- read.delim("H3K56ac_AS_wID.bed", header=FALSE)

H3K4me3_AS_wID <- read.delim("H3K4me3_AS_wID.bed", header=FALSE)


#Load in ASE promoter file that contain geneid info
#These were generated in RegioneR_analysis.R using output of GeneiASE and promoter info

RNA1_results <- read.delim("RNA1_results.txt")
RNA2_results <- read.delim("RNA2_results.txt")


ASE_promoter1_info <- read.delim("ASE_promoter1_info.txt")

ASE_promoter2_info <- read.delim("ASE_promoter2_info.txt")


#Check how many genes show ASE in one rep but not the other
dim(anti_join(ASE_promoter1_info,ASE_promoter2_info,by =c("feat")))

Both_reps_geneiase <- merge(RNA1_results,RNA2_results, by =c("feat"))


ggscatter(Both_reps_geneiase, x = "fdr.x", "fdr.y",add = "reg.line", conf.int = TRUE, size = 0.1) + stat_cor(aes(),method = "spearman") + xlim(0,0.05) + ylim(0,0.05)

#select only samples that are significant
signif <- Both_reps_geneiase %>% filter(fdr.x <= 0.05 & fdr.y <= 0.05)

ggscatter(signif, x = "fdr.x", "fdr.y",add = "reg.line", conf.int = TRUE, size = 0.1) + stat_cor(aes(),method = "spearman")

length(unique(signif$feat))

#merge ASE promoters from Reps 1 and 2
ase_prom_bothreps <- merge(ASE_promoter1_info, ASE_promoter2_info, by = c("feat"))

Same_block_all <- merge(Same_block, ase_prom_bothreps, by.x = c("ASE_gene_chr", "gene_start","gene_end"), by.y = c("chr.x","start.x","end.x"))

print("Number of genes with ASE in both reps, that have nearest AS ACR")

print(length(unique(Same_block_all[(Same_block_all$Mark == "ATAC"),]$geneid)))

Same_block_all <-Same_block_all[,c(1:14)]

phased_sets <- read.delim("SNPs_with_ancestry_assignment.sort.bed",header=F)

colnames(phased_sets) <- c("chr","pos","GT")

print("Loading Read counts with peak IDs ")

###Load in files with SNP IDs, genids counts, and location
RNA1_with_pos <- read.delim("RNA1_with_pos.tab")

RNA2_with_pos <- read.delim("RNA2_with_pos.tab")

ATAC_counts_with_pos <- read.delim("ATAC_counts_with_pos.tab")

H3K4me3_counts_with_pos <- read.delim("/bigdata/seymourlab/idiaz026/Results/Fairchild/ASE_calling/H3K4me3_counts_with_pos.tab")

H3K36me3_with_pos <- read.delim("H3K36me3_with_pos.tab")

H3K27me3_with_pos <- read.delim("H3K27me3_with_pos.tab")

H3K56ac_with_pos <- read.delim("H3K56ac_with_pos.tab")

df_list <- list(RNA1_with_pos,RNA2_with_pos,ATAC_counts_with_pos,H3K4me3_counts_with_pos,H3K36me3_with_pos,H3K56ac_with_pos,H3K27me3_with_pos)


for_geneiase <- list()

for (i in 1:length(df_list)) {
 for_geneiase[[i]] <- merge(df_list[[i]],phased_sets, by=c("chr","pos"))
 for_geneiase[[i]]$HAP1 <- ifelse(for_geneiase[[i]]$GT == "0|1", for_geneiase[[i]]$ref.dp, for_geneiase[[i]]$alt.dp)
 for_geneiase[[i]]$HAP2 <- ifelse(for_geneiase[[i]]$GT == "0|1", for_geneiase[[i]]$alt.dp, for_geneiase[[i]]$ref.dp)
 for_geneiase[[i]]$HAP1 <- as.numeric(for_geneiase[[i]]$HAP1)
 for_geneiase[[i]]$HAP2 <- as.numeric(for_geneiase[[i]]$HAP2)

}

get_counts <- function(df) {
 return(df %>% group_by(gene) %>% summarize(HAP1 = sum(HAP1),HAP2 = sum(HAP2)))
}

all_counts <- lapply(for_geneiase, get_counts)

#rename colnames for REP2 to make distinguishing easier in next step
colnames(all_counts[[2]]) <- c("gene","HAP1_rep2","HAP2_rep2")

subset_1 <- list()
subset_1_wID <- list()
gene_only_counts <- list()
gene_only_counts_wrep2 <- list()
all_marks_counts <- list() #merge subset one with respect mark counts

mark_types <- c("ATAC","H3K4me3","H3K36me3","H3K56ac","H3K27me3")
peaks_wIDs <- list(ATAC_AS_wID,H3K4me3_AS_wID,H3K36me3_AS_wID, H3K56ac_AS_wID, H3K27me3_AS_wID)

for ( i in 1:5) {
 subset_1[[i]] <- Same_block_all %>% filter(Mark == mark_types[[i]]) ### Separates counts by feature
 colnames(peaks_wIDs[[i]]) <- c("AS_mark_chr", "peak_start","peak_end","peak_id") #rename peaks to match with subset_1
 subset_1_wID[[i]] <- merge(subset_1[[i]],peaks_wIDs[[i]], by =c("AS_mark_chr","peak_start","peak_end"))
 gene_only_counts[[i]] <- merge(subset_1_wID[[i]], all_counts[[1]], by.x=c("geneid"), by.y=c("gene")) #merges mark info with gene counts from rep1
 gene_only_counts_wrep2[[i]] <- merge(gene_only_counts[[i]], all_counts[[2]], by.x=c("geneid"),by.y=c("gene"))
 all_marks_counts[[i]] <- merge(gene_only_counts_wrep2[[i]], all_counts[[i+2]], by.x=c("peak_id"), by.y = c("gene")) #merges ^ with counts of respective mark the all_counts[[i+1]] is to skip the gene expression df, so ATAC matches with ATAC
 all_marks_counts[[i]] <- unique(all_marks_counts[[i]][],) #keep only unique rows

 colnames(all_marks_counts[[i]]) <- c("Peak_id","geneid_full","AS_mark_chr","peak_start","peak_end","ASE_gene_chr","gene_start","gene_end","strand","Mark","peakid","gene_peak_distance","phaseblock_chr","phaseblock_start","phaseblock_end","HAP1_gene_count_REP1","HAP2_gene_count_REP1","HAP1_gene_count_REP2", "HAP2_gene_count_REP2","HAP1_peak_count", "HAP2_peak_count")
 all_marks_counts[[i]]$HAP1_gene_count_REP1 <- all_marks_counts[[i]]$HAP1_gene_count_REP1 + 1 ## Add pseudo counts for log2FC calculation
 all_marks_counts[[i]]$HAP2_gene_count_REP1 <- all_marks_counts[[i]]$HAP2_gene_count_REP1 + 1
 all_marks_counts[[i]]$HAP1_gene_count_REP2 <- all_marks_counts[[i]]$HAP1_gene_count_REP2 + 1 ## Add pseudo counts for log2FC calculation
 all_marks_counts[[i]]$HAP2_gene_count_REP2 <- all_marks_counts[[i]]$HAP2_gene_count_REP2 + 1
 all_marks_counts[[i]]$HAP1_peak_count<- all_marks_counts[[i]]$HAP1_peak_count + 1
 all_marks_counts[[i]]$HAP2_peak_count <- all_marks_counts[[i]]$HAP2_peak_count + 1
 all_marks_counts[[i]]$HAP1_log2FC_peak <- log2(all_marks_counts[[i]]$HAP1_peak_count) - log2(all_marks_counts[[i]]$HAP2_peak_count)
 all_marks_counts[[i]]$HAP1_log2FC_gene_REP1 <- log2(all_marks_counts[[i]]$HAP1_gene_count_REP1) - log2(all_marks_counts[[i]]$HAP2_gene_count_REP1)
 all_marks_counts[[i]]$HAP1_log2FC_gene_REP2 <- log2(all_marks_counts[[i]]$HAP1_gene_count_REP2) - log2(all_marks_counts[[i]]$HAP2_gene_count_REP2)

}
head(all_marks_counts[[1]])
dim(all_marks_counts[[1]])

##examine correlation between reps
##Relationship between log2fc BETWEEN REPS

ggscatter(all_marks_counts[[1]], x = "HAP1_log2FC_gene_REP1", "HAP1_log2FC_gene_REP2",add = "reg.line", conf.int = TRUE, size = 0.5) + stat_cor(aes(),method = "spearman")

##relationship of raw counts for HAP1 across reps
ggscatter(all_marks_counts[[1]], x = "HAP1_gene_count_REP1", "HAP1_gene_count_REP2",add = "reg.line", conf.int = TRUE, size = 0.5) + stat_cor(aes(),method = "spearman")



#Now I need generate a null comparison, this will include genes and ACRs that do not show allele specificity

print("load in results of geneiase just to extract peaks that made it to analysis")
ATAC_results <- read.delim("ATAC_results.txt")

H3K4me3_results <- read.delim("/bigdata/seymourlab/idiaz026/Results/Fairchild/ASE_calling/GeneiASE_outputs/H3K4me3_results.txt")

H3K36me3_results <- read.delim("
H3K56ac_results <- read.delim("H3K56ac_results.txt")

H3K27me3_results <- read.delim("H3K27me3_results.txt")



print("load all peak to get coord of geneiase peaks")

Atac_peaks_sorted_CORRECT <- read.delim("ACRs_final.bed", header=FALSE)

H3K36me3_peaks.txt.bed <- read.delim("H3K36me3_peaks.txt.bed", header=FALSE)

H3K4me3_peaks.txt.bed <- read.delim("H3K4me3_peaks.txt.bed", header=FALSE)

H3K27me3_peaks.txt.bed <- read.delim("H3K27me3_peaks.txt.bed", header=FALSE)

H3K56ac_peaks.txt.bed <- read.delim("H3K56ac_peaks.txt.bed", header=FALSE)


ATAC_results$Mark <- "ATAC"
H3K4me3_results$Mark <- " H3K4me3"
H3K36me3_results$Mark <- " H3K36me3"
H3K56ac_results$Mark <- " H3K56ac"
H3K27me3_results$Mark <- "H3K27me3"

list_geneiase_res <- list(ATAC_results,H3K4me3_results,H3K36me3_results,H3K56ac_results,H3K27me3_results)

list_peak_coord <- list(Atac_peaks_sorted_CORRECT,H3K4me3_peaks.txt.bed,H3K36me3_peaks.txt.bed,H3K56ac_peaks.txt.bed,H3K27me3_peaks.txt.bed)

output <- list()

for (i in 1:5) {
 output[[i]] <- merge(list_geneiase_res[[i]], list_peak_coord[[i]], by.x = c("feat"), by.y=c("V4"))
 output[[i]] <- output[[i]][,c("V1","V2","V3","feat")]
}

##Load in data
geneiase_prom_geneiase_peak_nonASE_phase_block <- read.delim("geneiase_prom_geneiase_peak_nonASE_phase_block.bed", header=FALSE)

colnames(geneiase_prom_geneiase_peak_nonASE_phase_block) <- c("Prom_chr","Prom_start","Prom_end","strand","geneid",
"Mark","Peak_chr","Peak_start","Peak_end","Peak_id","Peak_prom_distance","Phase_block_chr","Phase_block_start","Phase_block_end")

geneiase_prom_geneiase_peak_nonASE_phase_block <- geneiase_prom_geneiase_peak_nonASE_phase_block[grepl("-T1", geneiase_prom_geneiase_peak_nonASE_phase_block$geneid),]

Same_block <- geneiase_prom_geneiase_peak_nonASE_phase_block %>% filter(Prom_chr == Phase_block_chr & Prom_start >= Phase_block_start & Prom_end <= Phase_block_end & Peak_start >= Phase_block_start & Peak_end <= Phase_block_end)


print("Summary of control set before filtering for phase block matching")
print(table(geneiase_prom_geneiase_peak_nonASE_phase_block$Mark))
print("After filtering genes and nearest peaks that are in same phase block")
print(table(Same_block$Mark))

print("Load all promoter info")

All_promoters.sort <- read.delim("All_promoters.sort.bed", header=FALSE)
colnames(All_promoters.sort) <- c("Prom_chr","Prom_start","Prom_end","geneid")
#keep only T1
All_promoters.sort <- All_promoters.sort[grepl("-T1", All_promoters.sort$geneid),]


###Add geneids to Same_block using promoters
Same_block_wID <- merge(Same_block, All_promoters.sort, by=c("Prom_chr","Prom_start","Prom_end"))

Same_block_wID <- Same_block_wID %>% filter(geneid.x == geneid.y)

print("Constructing control set")
subset_1_b <- list()
subset_1_wID_b <- list()
gene_only_counts_b <- list()
gene_only_counts_wrep2_b <- list()
Non_AS_all_marks_counts <- list()


mark_types <- c("ATAC","H3K4me3","H3K36me3","H3K56ac","H3K27me3")


for ( i in 1:5) {
 subset_1_b[[i]] <- Same_block_wID %>% filter(Mark == mark_types[[i]]) ### Separates counts by feature
 gene_only_counts_b[[i]] <- merge(subset_1_b[[i]], all_counts[[1]], by.x=c("geneid.x"), by.y=c("gene")) #merges mark info with gene counts from rep1
 gene_only_counts_wrep2_b[[i]] <- merge(gene_only_counts_b[[i]], all_counts[[2]], by.x=c("geneid.x"),by.y=c("gene"))
 Non_AS_all_marks_counts[[i]] <- merge(gene_only_counts_wrep2_b[[i]], all_counts[[i+2]], by.x=c("Peak_id"), by.y = c("gene")) #merges ^ with counts of respective mark the all_counts[[i+1]] is to skip the gene expression df, so ATAC matches with ATAC
 Non_AS_all_marks_counts[[i]] <- unique(Non_AS_all_marks_counts[[i]][],) #keep only unique rows

 colnames(Non_AS_all_marks_counts[[i]]) <- c("Peak_id","geneid_full","ASE_gene_chr","gene_start","gene_end","strand","Mark","AS_mark_chr","peak_start","peak_end","gene_peak_distance","phaseblock_chr","phaseblock_start","phaseblock_end","geneid","HAP1_gene_count_REP1","HAP2_gene_count_REP1","HAP1_gene_count_REP2", "HAP2_gene_count_REP2","HAP1_peak_count", "HAP2_peak_count")
 Non_AS_all_marks_counts[[i]]$HAP1_gene_count_REP1 <- Non_AS_all_marks_counts[[i]]$HAP1_gene_count_REP1 + 1 ## Add pseudo counts for log2FC calculation
 Non_AS_all_marks_counts[[i]]$HAP2_gene_count_REP1 <-  Non_AS_all_marks_counts[[i]]$HAP2_gene_count_REP1 + 1
 Non_AS_all_marks_counts[[i]]$HAP1_gene_count_REP2 <-  Non_AS_all_marks_counts[[i]]$HAP1_gene_count_REP2 + 1 ## Add pseudo counts for log2FC calculation
 Non_AS_all_marks_counts[[i]]$HAP2_gene_count_REP2 <-  Non_AS_all_marks_counts[[i]]$HAP2_gene_count_REP2 + 1
 Non_AS_all_marks_counts[[i]]$HAP1_peak_count<-  Non_AS_all_marks_counts[[i]]$HAP1_peak_count + 1
 Non_AS_all_marks_counts[[i]]$HAP2_peak_count <-  Non_AS_all_marks_counts[[i]]$HAP2_peak_count + 1
 Non_AS_all_marks_counts[[i]]$HAP1_log2FC_peak <- log2( Non_AS_all_marks_counts[[i]]$HAP1_peak_count) - log2( Non_AS_all_marks_counts[[i]]$HAP2_peak_count)
 Non_AS_all_marks_counts[[i]]$HAP1_log2FC_gene_REP1 <- log2( Non_AS_all_marks_counts[[i]]$HAP1_gene_count_REP1) - log2( Non_AS_all_marks_counts[[i]]$HAP2_gene_count_REP1)
 Non_AS_all_marks_counts[[i]]$HAP1_log2FC_gene_REP2 <- log2( Non_AS_all_marks_counts[[i]]$HAP1_gene_count_REP2) - log2( Non_AS_all_marks_counts[[i]]$HAP2_gene_count_REP2)


}

g <- cor.test(all_marks_counts[[1]]$HAP1_log2FC_peak, all_marks_counts[[1]]$HAP1_log2FC_gene_REP1, method = "spearman",conf.level = 0.95)

g[["conf.int"]][2]
#make function to do correlations
do_corr_1 <- function(df) {
 corr1_test <-cor.test(df$HAP1_log2FC_peak, df$HAP1_log2FC_gene_REP1, method = "spearman",conf.level = 0.95)
 rs <- cor(df$HAP1_log2FC_peak, df$HAP1_log2FC_gene_REP1,method="spearman",use="complete.obs")
 n <- sum(complete.cases(df$HAP1_log2FC_peak, df$HAP1_log2FC_gene_REP1))
 conf_int <- sort(tanh(atanh(rs) + c(-1,1)*sqrt((1+rs^2/2)/(n-3))*qnorm(p = 0.05/2)))

 corr1_rho <- corr1_test$estimate[[1]]
 corr1_lower <- conf_int[1]
 corr1_upper <- conf_int[2]
 corr1_values <- c(corr1_rho,corr1_lower,corr1_upper)} #FOR REP 1 rna seq



do_corr_2 <- function(df) {
 corr2_test <-cor.test(df$HAP1_log2FC_peak, df$HAP1_log2FC_gene_REP2, method = "spearman",conf.level = 0.95)
 rs <- cor(df$HAP1_log2FC_peak, df$HAP1_log2FC_gene_REP2,method="spearman",use="complete.obs")
 n <- sum(complete.cases(df$HAP1_log2FC_peak, df$HAP1_log2FC_gene_REP2))
 conf_int <- sort(tanh(atanh(rs) + c(-1,1)*sqrt((1+rs^2/2)/(n-3))*qnorm(p = 0.05/2)))

 corr_rho2 <- corr2_test$estimate[[1]]
 corr2_lower <- conf_int[1]
 corr2_upper <- conf_int[2]
 corr2_values <- c(corr_rho2,corr2_lower,corr2_upper)} #For Rep2 rna seq
####################
##################

non_zero_distance <- list() #first need to filter out gene peak distance that are zero
corrs_REP1 <- list() #this stores corr between peak and rep1 gene expression
corrs_REP2 <- list() #rep2
corr1<- list() #store full output of cor.test
corr1_test<-list()
corr1_values <- list()
corr_rho1 <- list()
corr1_lower <- list() #store conf int lower
corr1_upper <- list() #store_conf int upper

corr2 <- list() #store full output of cor.test
corr2_test<-list()
corr2_values <- list()
corr_rho2 <- list()
corr2_lower <- list() #store conf int lower
corr2_upper <- list() #store_conf int upper
corr2 <- list()
corr_all <- list() #for merging cor1 and cor2

########
#########

zero_non_as <- Non_AS_all_marks_counts[[1]] %>% filter(gene_peak_distance == 0)
zero_all <- all_marks_counts[[1]] %>% filter(gene_peak_distance == 0)

ATAC_all <- Non_AS_all_marks_counts[[1]] %>% filter(abs(gene_peak_distance) > 0 )

ATAC_AS_ <- all_marks_counts[[1]] %>% filter(abs(gene_peak_distance) > 0)


##
ATAC_all$Distance_quant <- quantcut(abs(ATAC_all$gene_peak_distance), q = 25)

ATAC_AS_$Distance_quant <- quantcut(abs(ATAC_AS_$gene_peak_distance), q = 25)

#do correlation
zero_non_as_corr <- t(as.data.frame(do_corr_1(zero_non_as)))
zero_non_as_corr[4] <- 0
zero_all_corr <- t(as.data.frame(do_corr_1(zero_all)))
zero_all_corr[4] <- 0

#REP2
zero_non_as_corr2 <- t(as.data.frame(do_corr_2(zero_non_as)))
zero_non_as_corr2[4] <- 0

zero_all_corr2 <- t(as.data.frame(do_corr_2(zero_all)))
zero_all_corr2[4] <- 0

##add type
zero_non_as_corr[5] <- "Control"
zero_all_corr[5] <- "AS"
zero_non_as_corr2[5] <- "Control"
zero_all_corr2[5] <- "AS"

##Add Rep as a column
zero_non_as_corr[6] <- "1"
zero_all_corr[6] <- "1"
zero_non_as_corr2[6] <- "2"
zero_all_corr2[6] <- "2"


##### Now do this for non zero distance quants

AS_corr1 <- lapply(split(ATAC_AS_, ATAC_AS_$Distance_quant), do_corr_1)

AS_corr2 <- lapply(split(ATAC_AS_, ATAC_AS_$Distance_quant), do_corr_2)

### Now for AS genes
AS_corr1_df <- data.frame(matrix(unlist(AS_corr1),nrow = length(AS_corr1), byrow = TRUE))
AS_corr1_df$Distance <- as.numeric(gsub("\\[?\\(?(.*?)\\,.*?\\]", "\\1",names(AS_corr2)))

#REP2
AS_corr2_df <- data.frame(matrix(unlist(AS_corr2),nrow = length(AS_corr2), byrow = TRUE))
AS_corr2_df$Distance <- as.numeric(gsub("\\[?\\(?(.*?)\\,.*?\\]", "\\1",names(AS_corr2)))



#extract start and end of each quantile, group control by these criteria, randomly sample 30 rows and calculate correlation, store separately
start <- vector()
end <- vector()
count <- 0
for (i in 1:25) {
 start[i] <- AS_corr1_df$Distance[i]
 end[i] <- AS_corr1_df$Distance[i+1]
}
end[25] <- 2500000


corr_sub <- list()
corr_perm1 <- list()
corr_perm2 <- list()
corr_fin1 <- list()
corr_fin2 <- list()


#Create control group with equal number of obs
set.seed(123)
for (i in 1:10){
 corr_sub[[i]] <- ATAC_all %>% filter(gene_peak_distance >= start[i] & gene_peak_distance < end[i])
 corr_sub[[i]]$Quant <- start[i]
 corr_perm1[[i]] <- t(replicate(do_corr_1(corr_sub[[i]] %>% slice_sample(n=52,replace=T)),n=1000,simplify = TRUE))
 corr_perm2[[i]] <-t(replicate(do_corr_2(corr_sub[[i]] %>% slice_sample(n=30,replace=T)),n=1000,simplify = TRUE))
 corr_fin1[[i]] <- colMeans(corr_perm1[[i]])
 corr_fin2[[i]] <- colMeans(corr_perm2[[i]])
 corr_fin1[[i]][4] <-start[i]
 corr_fin2[[i]][4] <-start[i]

}


table(ATAC_AS_$Distance_quant)


##########   Change lists from ^^ to dataframes
###################

non_as_corr1_df <- data.frame(matrix(unlist(corr_fin1),nrow = length(corr_fin1), byrow = TRUE))


#REP2
non_as_corr2_df <- data.frame(matrix(unlist(corr_fin2),nrow = length(corr_fin2), byrow = TRUE))


##Make columns to match with zero distance correlations
non_as_corr1_df$Type <- "Control"
non_as_corr2_df$Type <- "Control"
AS_corr1_df$Type <- "AS"
AS_corr2_df$Type <- "AS"


##Make Column with rep
non_as_corr1_df$Rep <- "1"
non_as_corr2_df$Rep <- "2"
AS_corr1_df$Rep <- "1"
AS_corr2_df$Rep <- "2"

colnames(non_as_corr1_df) <- c("Rho","Lower_CI","Upper_CI","Distance","Type","Rep")
colnames(non_as_corr2_df) <- c("Rho","Lower_CI","Upper_CI","Distance","Type","Rep")
colnames(AS_corr1_df) <- c("Rho","Lower_CI","Upper_CI","Distance","Type","Rep")
colnames(AS_corr2_df) <- c("Rho","Lower_CI","Upper_CI","Distance","Type","Rep")


### Now combine into a single df
Final_ATAC_correlations <- rbind(zero_all_corr, zero_all_corr2, zero_non_as_corr, zero_non_as_corr2, non_as_corr1_df, non_as_corr2_df, AS_corr1_df, AS_corr2_df)

colnames(Final_ATAC_correlations) <- c("Rho","Lower_CI","Upper_CI","Distance","Type","Rep")

#Convert columns that are supposed to be numeric to numeric
Final_ATAC_correlations$Rho <- as.numeric(Final_ATAC_correlations$Rho)
Final_ATAC_correlations$Lower_CI <- as.numeric(Final_ATAC_correlations$Lower_CI)
Final_ATAC_correlations$Upper_CI <- as.numeric(Final_ATAC_correlations$Upper_CI)
Final_ATAC_correlations$Distance <- as.numeric(Final_ATAC_correlations$Distance)

## Plot!



ggplot(Final_ATAC_correlations, aes(Distance, Rho, group = Type,color = Type)) + geom_point(size =2) + geom_errorbar(aes(ymin=Lower_CI, ymax = Upper_CI))


#Its hard to see whats goin on, separaete by rep

Final_ATAC_correlations1 <- Final_ATAC_correlations %>% filter(Rep == 1)
Final_ATAC_correlations2 <- Final_ATAC_correlations %>% filter(Rep == 2)


#R1
ggplot(Final_ATAC_correlations1, aes(Distance, Rho, group = Type,color = Type)) + geom_point(aes(size = Final_ATAC_correlations1$Percent_upstream)) + geom_errorbar(aes(ymin=Lower_CI, ymax = Upper_CI),alpha = 0.5) + xlim(0,100000) + geom_line() + theme_bw() + ggtitle("Correlation of Maternal_log2FC ATAC and RNAseq rep1") + xlab("Gene to ACR distance") + scale_color_manual(values=c("slateblue1","slategrey"))+ labs(size="% of ACRs upstream of nearest gene",col="Type")
#R2
ggplot(Final_ATAC_correlations2, aes(Distance, Rho, group = Type,color = Type)) + geom_point(aes(size = Final_ATAC_correlations1$Percent_upstream)) + geom_errorbar(aes(ymin=Lower_CI, ymax = Upper_CI),alpha = 0.5) +xlim(0,100000) + geom_line() + theme_bw() + ggtitle("Correlation of Maternal log2FC ATAC and RNAseq rep2") + xlab("Gene to ACR distance") + scale_color_manual(values=c("slateblue1","slategrey")) + labs(size="% of ACRs upstream of nearest gene",col="Type")



#how many AS ACRs are duplicated
filt <- all_marks_counts[[1]] %>% filter(abs(gene_peak_distance) < 5000)

#remove dups
dups <- duplicated(filt$Peak_id)
rm_dup <- filt[-which(dups),]

#export
write.table(rm_dup,"2023-06-14_ATAC_RNA_ASE.txt", col.names=TRUE, row.names=FALSE, sep = "\t", quote=FALSE)
#plot
ggscatter(rm_dup, x = "HAP1_log2FC_peak", y = "HAP1_log2FC_gene_REP1",add = "reg.line") + stat_cor(label.x=-1, label.y = 8, size = 7,method="spearman")  +theme(text=element_text(size=15)) + scale_color_manual(values=c("slateblue1")) + ggtitle("ASE genes with AS ACR less than 5kb away") + xlab("log2FC(Maternal/Paternal) ATAC") + ylab("log2FC(Maternal/Paternal) RNA")+ ylim(-5,10)


ggscatter(all_marks_counts[[1]], x = "HAP1_log2FC_peak", y = "HAP1_log2FC_gene_REP1",add = "reg.line") + stat_cor(label.x=-1, label.y = 8, size = 7,method="spearman")  +theme(text=element_text(size=15)) + scale_color_manual(values=c("slateblue1")) + ggtitle("ASE genes with AS ACR in same phaseblock") + xlab("log2FC(Maternal/Paternal) ATAC") + ylab("log2FC(Maternal/Paternal) RNA")

plot(rm_dup$HAP1_log2FC_peak,rm_dup$HAP1_log2FC_gene_REP1)





#randomly shuffle obs
shuff_gene <- sample(rm_dup$HAP1_log2FC_gene_REP1, 51)
shuff_peak <- sample(rm_dup$HAP1_log2FC_peak, 51)

shuff <- as.data.frame(cbind(shuff_gene,shuff_peak))

ggscatter(shuff, x = "shuff_peak", y = "shuff_gene",add = "reg.line") + stat_cor(label.x=-2, label.y = 4, size = 7,method="spearman")  +theme(text=element_text(size=15)) + scale_color_manual(values=c("slateblue1")) + ggtitle("ASE genes with AS ACR less than 5kb away randomly Shuffled control") + ylim(-5,5) + xlim(-2,2)

plot(rm_dup$HAP1_log2FC_peak,rm_dup$HAP1_log2FC_gene_REP1)
abline(lm(rm_dup$HAP1_log2FC_gene_REP1~rm_dup$HAP1_log2FC_peak))

b <- lm(rm_dup$HAP1_log2FC_gene_REP1~rm_dup$HAP1_log2FC_peak)


summary(b)
